import argparse
import os
import sys
from collections import OrderedDict, defaultdict
from datetime import datetime
from typing import List

import clipboard


def readline_until_not_empty(f):
    line = f.readline().strip()
    while line == "":
        line = f.readline().strip()
    if line is None:
        raise EOFError("Unexpected EOF while reading an res file")
    return line


def case_insensitive_compare(str0, str1):
    return str0.lower() == str1.lower()


def clean_strip(line):
    return list(map(str.strip, line.strip(";").strip().split(",")))


def create_res_file_mapping(res_rows: List[dict]) -> dict:
    mapping = OrderedDict()
    for row in res_rows:
        mapping[row["header"]["tr_code"]] = row
    return mapping


def parse_res(filepath, include_human_readable_info=True, print_as_pythonclass=False):
    PYTHONTYPE = {
        "char": "str",
        "long": "int",
    }

    ret = {}
    with open(filepath, "r", encoding="cp949") as f:
        # find BEGIN_FUNCTION_MAP start point
        line = readline_until_not_empty(f)
        while not case_insensitive_compare(line, "BEGIN_FUNCTION_MAP"):
            line = readline_until_not_empty(f)

        # parse tr_code
        line = readline_until_not_empty(f)
        contents = clean_strip(line)

        # query or subscription
        is_query = case_insensitive_compare(contents[0], ".Func")
        desc = contents[1]

        # DOCS: tr_code
        # res 파일속의 tr코드와 파일이름의 tr코드가 다른경우가 있음
        # 추측컨데, 비슷한 tr코드를(ex: 'YS3' vs. 'Ys3', Ys3->Ys3_4ELW)을 개발자들이 헷갈리지 않도록
        # 원래의 tr코드 그대로 사용치 않고 변화를 준 것 같음
        # 원래 TR코드보다는 res파일이름을 기준으로 tr_code 저장
        tr_code = os.path.split(filepath)[1].split(".")[0].strip()

        header = {"tr_code": tr_code, "is_query": is_query}
        if include_human_readable_info:
            header.update({"desc": desc, "path": filepath})

        ret.update({"header": header})

        # find BEGIN_DATA_MAP start point
        line = readline_until_not_empty(f)
        while not case_insensitive_compare(line, "BEGIN_DATA_MAP"):
            line = readline_until_not_empty(f)

        line = readline_until_not_empty(f)
        block = []
        while not case_insensitive_compare(line, "END_DATA_MAP"):
            a_block = {}
            contents = clean_strip(line)
            is_input = "input" in contents
            is_occurs = "occurs" in contents
            a_block.update(
                {"bname": contents[0], "is_input": is_input, "is_occurs": is_occurs},
            )

            line = readline_until_not_empty(f)
            while not case_insensitive_compare(line, "begin"):
                line = readline_until_not_empty(f)

            line = readline_until_not_empty(f)
            args = []
            while not case_insensitive_compare(line, "end"):
                contents = clean_strip(line)
                arg = {"code": contents[1]}
                if include_human_readable_info:
                    arg.update(
                        {
                            "desc": contents[0],
                            "type": contents[3],
                            "length": contents[4],
                        },
                    )
                if print_as_pythonclass:
                    print(
                        f"{arg['code']}: {PYTHONTYPE[arg['type']]} # {arg['desc']}, length: {arg['length']}",
                    )
                args.append(arg)
                line = readline_until_not_empty(f)
            a_block.update({"args": args})
            line = readline_until_not_empty(f)
            block.append(a_block)
        ret.update({"block": block})
        return ret


def create_pydantic_model(res_infos: List[dict]):
    statement = f"# Generated by res_converter.py - make_tr_order_model  {datetime.now().isoformat()}"
    statement += """
from typing import List

from pydantic import Field, BaseModel

"""
    outblock_names = []
    outblock_maps = defaultdict(set)
    inblock_names = []

    for res in res_infos:
        # Class 1: MMDAQ91200InBlock1
        statement += (
            f"# region <{res['header']['tr_code']} - {res['header']['desc']}>\n"
        )
        for block in res["block"]:
            block_name = block["bname"]
            if "OutBlock" in block["bname"]:
                outblock_names.append(block_name)
            elif "InBlock" in block["bname"]:
                inblock_names.append(block_name)

            if len(block["args"]) > 0:
                if len(res["header"]["tr_code"]) == 3:
                    # SC0, HC1 같은 주문 관련 realtime tr들
                    class_name = f"{res['header']['tr_code']}{block_name}"
                else:
                    class_name = block_name
                statement += f"class {class_name}(BaseModel):\n"
                for arg in block["args"]:
                    if arg["type"] in ["float", "double"]:
                        statement += f"    {arg['code']}: float = Field(description='{arg['desc']}', default=0.0)\n"
                    elif arg["type"] == "long":
                        statement += f"    {arg['code']}: int = Field(description='{arg['desc']}', default=0)\n"
                    else:
                        statement += f"    {arg['code']}: str = Field(description='{arg['desc']}', default='')\n"
                statement += "\n\n"
        statement += "\n"

        # Class 2: MMDAQ91200
        def create_parent_base_model(bname, bname_lower, is_occurs):
            _statement = ""
            if is_occurs:
                _statement += f"    {bname_lower}: List[{bname}]"
            else:
                _statement += f"    {bname_lower}: {bname}"
            _statement += f" = Field(description='{bname}') \n"
            return _statement

        statement += f"# {res['header']['desc']} \n"
        statement += f"class {res['header']['tr_code']}(BaseModel):\n"
        for block in res["block"]:
            block_name = block["bname"]
            if len(res["header"]["tr_code"]) == 3:
                # SC0, HC1 같은 주문 관련 realtime tr들
                class_name = f"{res['header']['tr_code']}{block_name}"
                if "OutBlock" in block_name:
                    outblock_maps[res["header"]["tr_code"]].add(class_name)
            else:
                class_name = block_name
                if "OutBlock" in block_name:
                    outblock_maps[res["header"]["tr_code"]].add(class_name)

            if "OutBlock3" in block["bname"]:
                statement += create_parent_base_model(
                    class_name,
                    "outblock3",
                    block["is_occurs"],
                )
            elif "OutBlock2" in block["bname"]:
                statement += create_parent_base_model(
                    class_name,
                    "outblock2",
                    block["is_occurs"],
                )
            elif "OutBlock1" in block["bname"]:
                statement += create_parent_base_model(
                    class_name,
                    "outblock1",
                    block["is_occurs"],
                )
            elif "OutBlock" in block["bname"]:
                statement += create_parent_base_model(
                    class_name,
                    "outblock",
                    block["is_occurs"],
                )
            elif "InBlock1" in block["bname"]:
                if len(block["args"]) > 0:
                    statement += (
                        f"    inblock1: {res['header']['tr_code']}InBlock1 = "
                        f"Field(description='{res['header']['tr_code']}InBlock1') \n"
                    )
            elif "InBlock" in block["bname"]:
                if len(block["args"]) > 0:
                    statement += (
                        f"    inblock: {res['header']['tr_code']}InBlock = "
                        f"Field(description='{res['header']['tr_code']}InBlock') \n"
                    )
        statement += (
            " " * 4
            + f"metadata: dict = Field(description='The metadata information for {res['header']['tr_code']}', \
default_factory=lambda : dict())\n"
        )
        statement += "# endregion\n"
        statement += "\n"
        statement += "\n"

    statement += "QUERY_MAP = {\n"
    for res in res_infos:
        statement += f"    '{res['header']['tr_code']}': {res['header']['tr_code']},  # {res['header']['desc']}\n"
    statement += "}\n"
    statement += "\n"

    from pprint import pformat

    statement += f"QUERY_OUTBLOCK_MAP = {pformat(dict(outblock_maps))}"
    statement += "\n"
    statement += "\n"

    clipboard.copy(statement)


def create_msgspec_model_for_websocket(res_infos):
    statement = f"# Generated by res_converter.py - {sys._getframe().f_code.co_name} {datetime.now().isoformat()}"
    statement += """
from typing import List, Dict, Optional

import msgspec

"""
    outblock_names = []
    outblock_maps = defaultdict(set)
    inblock_names = []

    for res in res_infos:
        # Class 1: MMDAQ91200InBlock1
        statement += (
            f"# region <{res['header']['tr_code']} - {res['header']['desc']}>\n"
        )
        for block in res["block"]:
            block_name = block["bname"]
            if "OutBlock" in block["bname"]:
                outblock_names.append(block_name)
            elif "InBlock" in block["bname"]:
                inblock_names.append(block_name)

            if len(block["args"]) > 0:
                if len(res["header"]["tr_code"]) == 3:
                    # SC0, HC1 같은 주문 관련 realtime tr들
                    class_name = f"{res['header']['tr_code']}{block_name}"
                else:
                    class_name = block_name
                statement += f"class {class_name}(msgspec.Struct, frozen=True):\n"
                for arg in block["args"]:
                    if arg["type"] in ["float", "double"]:
                        statement += f"    {arg['code']}: float = 0.0 # {arg['desc']}\n"
                    elif arg["type"] == "long":
                        statement += f"    {arg['code']}: int = 0 # {arg['desc']}\n"
                    else:
                        statement += f"    {arg['code']}: str = '' # {arg['desc']}\n"
                statement += "\n\n"
        statement += "\n"

        # Class 2: MMDAQ91200
        def create_parent_base_model(bname, bname_lower, is_occurs):
            _statement = ""
            if is_occurs:
                _statement += f"    {bname}: Optional[List[{bname}]]"
            else:
                _statement += f"    {bname}: Optional[{bname}]"
            _statement += " = None \n"
            return _statement

        statement += f"# {res['header']['desc']} \n"
        statement += f"class {res['header']['tr_code']}(msgspec.Struct, frozen=True):\n"
        statement += " " * 4 + "rsp_cd: str = ''\n"
        statement += " " * 4 + "rsp_msg: str = ''\n"
        for block in res["block"]:
            block_name = block["bname"]
            if len(res["header"]["tr_code"]) == 3:
                # SC0, HC1 같은 주문 관련 realtime tr들
                class_name = f"{res['header']['tr_code']}{block_name}"
                if "OutBlock" in block_name:
                    outblock_maps[res["header"]["tr_code"]].add(class_name)
            else:
                class_name = block_name
                if "OutBlock" in block_name:
                    outblock_maps[res["header"]["tr_code"]].add(class_name)

            if "OutBlock3" in block["bname"]:
                statement += create_parent_base_model(
                    class_name,
                    "outblock3",
                    block["is_occurs"],
                )
            elif "OutBlock2" in block["bname"]:
                statement += create_parent_base_model(
                    class_name,
                    "outblock2",
                    block["is_occurs"],
                )
            elif "OutBlock1" in block["bname"]:
                statement += create_parent_base_model(
                    class_name,
                    "outblock1",
                    block["is_occurs"],
                )
            elif "OutBlock" in block["bname"]:
                statement += create_parent_base_model(
                    class_name,
                    "outblock",
                    block["is_occurs"],
                )
        statement += "# endregion\n"
        statement += "\n"
        statement += "\n"

    statement += "QUERY_MAP = {\n"
    for res in res_infos:
        statement += f"    '{res['header']['tr_code']}': {res['header']['tr_code']},  # {res['header']['desc']}\n"
    statement += "}\n"
    statement += "\n"

    from pprint import pformat

    statement += f"QUERY_OUTBLOCK_MAP = {pformat(dict(outblock_maps))}"
    statement += "\n"
    statement += "\n"

    clipboard.copy(statement)


def cli(task, path):
    res_file_paths = list(
        map(
            lambda file_name: os.path.join(path, file_name),
            [
                file
                for file in os.listdir(path)
                if os.path.isfile(os.path.join(path, file))
            ],
        ),
    )
    res_file_paths = list(
        filter(
            lambda fn: not fn.find("_") > 0,
            res_file_paths,
        ),
    )
    res_rows = [parse_res(path) for path in res_file_paths]
    res_map = create_res_file_mapping(res_rows)

    if task == "create_pydantic_model":
        res_code = []
        for k in res_map.keys():
            res_code.append(k)
        res_code.sort()

        res_infos = [res_map[name] for name in res_code]
        create_pydantic_model(res_infos=res_infos)
    elif task == "create_msgspec_model_for_websocket":
        res_code = []
        for k in res_map.keys():
            res_code.append(k)
        res_code.sort()

        res_infos = [res_map[name] for name in res_code]
        create_msgspec_model_for_websocket(res_infos=res_infos)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="CLI Tool")

    # Choices for the task argument
    choices = [
        "create_pydantic_model",
        "create_msgspec_model_for_websocket",
    ]

    parser.add_argument(
        "task",
        choices=choices,
        help="Task to perform.",
    )

    parser.add_argument(
        "--path",
        default="./res",
        help="The default xing api res file path.",
    )

    args = parser.parse_args()
    cli(args.task, args.path)
